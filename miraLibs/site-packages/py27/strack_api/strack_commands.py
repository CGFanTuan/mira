# coding=utf8
# Copyright (c) 2017 CineUse
import copy
import json
import os
import logging
import warnings
import requests
from strack_utils import parse_filter_expression as pfe
from strackerror import *
from value_map import VALUE_MAP

current_dir = os.path.dirname(__file__)

for k, v in logging.Logger.manager.loggerDict.iteritems():
    if isinstance(v, logging.Logger) and ("requests" in k):
        v.setLevel(logging.CRITICAL)


class Command(object):
    """
    command base class
    """

    def __init__(self, server_object, cmd, params, entity=None):
        """It's a Command...'"""
        self.controller, self.func_name = cmd.split("/")
        self.__name__ = "Strack.%s" % cmd.replace("/", ".")
        self.__server = server_object
        self.__entity = entity or server_object
        self._params = params or []
        self.cmd = cmd
        self.__request = []
        self.logger = self.server.logger
        self._retry_times = 0
        self.__doc__ = self.help()

    def help(self):
        """
        show help info of a method.
        Returns:
            a string of help info
        """
        help_info = []
        if self.func_name in self.entity.methods:
            help_info.append("Method %s.%s" % (self.entity.name, self.func_name))
            # find description from doc folder
            doc_path = os.path.join(current_dir, "docs", "%s.json" % self.entity.name)
            description = ""
            if os.path.isfile(doc_path):
                with open(doc_path) as f:
                    doc_dict = json.loads(f.read())
                    description = doc_dict.get(self.func_name, "")
            if not description:
                description = self.server.general_help.get(self.func_name, "")
            help_info.append(description)
            # list arguments
            argument_list = self._params
            if argument_list:
                help_info.append("Arguments:")
                help_info.append("\t %-20s %-20s %-20s" % ("arg_name", "type", "is_requisite"))
                help_info.append("-" * 64)
                for argument in argument_list:
                    help_info.append("\t %(attr)-20s %(type)-20s %(need)-20s" % argument)
            else:
                help_info.append("No Arguments Found")
        else:
            help_info.append("Method %s.%s is not exists." % (self.entity.name, self.func_name))
        return "\n".join(help_info)

    @property
    def url(self):
        return self.__server.cmd_to_url(self.cmd)

    @property
    def server(self):
        return self.__server

    @property
    def entity(self):
        return self.__entity

    @property
    def params(self):
        return [i.get("attr") for i in self._params]

    @property
    def request(self):
        return self.__request

    def __call__(self, *args, **kwargs):
        self.__request = (args, kwargs)
        payload, upload_file = self._init_requests(args, kwargs) or [None, None]
        response = self.__execute(payload, upload_file)
        return self.__handle_response(response)

    def _init_payload(self, args, kwargs):
        payload = {
            "sign": self.server.sign_code,
            "unique": self.server.unique_code
        }

        payload = self._set_arguments(args, kwargs, payload)

        return payload

    def _init_requests(self, args, kwargs):
        return self._init_payload(args, kwargs), None

    def _demap_fields(self, user_fields_dict):
        server_fields_dict = {}
        for field_name, value in user_fields_dict.iteritems():
            field_name = self.server.demap_field(self.entity.name, field_name)
            server_fields_dict[field_name] = value
        return server_fields_dict

    def _map_fields(self, entity_and_fields):
        entity_name, server_fields_dict = entity_and_fields
        user_fields_dict = {}
        for field_name, value in server_fields_dict.iteritems():
            field_name = self.server.map_field(entity_name, field_name)
            user_fields_dict[field_name] = value
        return user_fields_dict

    def _map_str_to_int(self, entity_and_fields):
        entity_name, fields_dict = entity_and_fields
        for field, value in fields_dict.iteritems():
            if not isinstance(value, (basestring, bool)):
                continue
            map_lists = VALUE_MAP.get(entity_name, {}).get(field, [])
            map_dict = dict(map(reversed, map_lists))
            new_value = map_dict.get(value, value)
            if isinstance(new_value, int):
                fields_dict[field] = new_value
        return fields_dict

    def _map_int_to_str(self, entity_and_result):
        entity_name, result_dict = entity_and_result
        result_dict_copied = copy.deepcopy(result_dict)
        for field, value in result_dict_copied.iteritems():
            if not isinstance(value, int):
                continue
            result_dict.pop(field)
            new_field = self.server.map_field(entity_name, field)  # won't effect default fields
            # map int values
            new_value = dict(VALUE_MAP.get(entity_name, {}).get(new_field, [])).get(
                value, value)
            result_dict[new_field] = new_value
        return result_dict

    def _validate_param(self, param_name, param_type, value):
        # type validate
        type_map = {
            "list": list,
            "dict": dict,
            "str": basestring,
            "int": int,
            "float": float
        }
        if param_name not in self.params:
            raise ValueError("%s is not a validate argument." % param_name)
        if not isinstance(value, type_map.get(param_type)):
            raise ValueError(
                "Argument '%s' must be a '%s' type object, not '%s'" % (param_name, param_type, type(value)))
        return value

    def _set_arguments(self, args, kwargs, payload):
        # prepare parameters
        args = list(args[1:])  # 'tuple' object has no attribute 'pop', index 0 is entity_name
        kwargs = copy.deepcopy(kwargs)
        for parameter in self._params:
            value = None
            param_name = parameter.get("attr")
            param_type = parameter.get("type")
            param_requisite = parameter.get("need")

            if args:
                value = args.pop(0)
            elif param_name in kwargs:
                value = kwargs.pop(param_name)
            elif param_requisite:
                raise ValueError(
                    "Required argument '%s' not found" % param_name)

            if value:
                value = self._validate_param(param_name, param_type, value)
                if not isinstance(value, basestring):
                    value = json.dumps(value)
                payload.update({param_name: value})
        if args or kwargs:
            raise ValueError("Wrong arguments. %s %s" % (str(args), str(kwargs)))
        return payload

    def __execute(self, payload, upload_file):
        # execute
        # print ">>"
        # print self.url
        # print payload
        # print upload_file
        result = requests.post(self.url, data=payload, files=upload_file)
        if upload_file:
            upload_file["file"].close()
        return result

    def __handle_response(self, response):
        # handle response
        if response.status_code in {200, 201, 202, 204}:
            return self._success(response)

        else:
            return self.__failed(response)

    def _success(self, response):
        res = response.json()
        result = res.get("data", True)
        self._retry_times = 0
        return result

    def __failed(self, response):
        if response.status_code == 400:
            res = response.json()
            result = "%s: %s \n" % (res.get("status"), res.get("message") or "Done")
            self.logger.info(result)
            warnings.warn(result)
            return False
        elif response.status_code == 401:
            error_info = "401: %s" % response.json().get("message")
            if self._retry_times < 3:
                self._retry_times += 1
                self.__server.get_sign_code()
                return self.__call__(*self.__request[0], **self.__request[1])
            else:
                raise StrackError(error_info)
        elif response.status_code in [422, 403]:
            # 重新申请令牌
            self.__server.get_sign_code()
            return self.__call__(*self.__request[0], **self.__request[1])
        elif response.status_code == 404:
            error_msg = response.json().get("message")
            error_msg = error_msg.encode("utf-8")
            raise StrackError("404: no response.\n%s" % error_msg)
        elif response.status_code == 406:
            if "default_fields" in response.json():
                fields = response.json().get("default_fields")
                error_info = "%s: %s \nBelow are the valid fields:\n%s" % (
                    response.status_code, response.json()["message"], "\n".join(fields))
                raise StrackError(error_info)
            error_info = "%s: %s" % (response.status_code, response.json()["message"])
            raise StrackError(error_info)
        elif response.status_code == 500:
            print response.status_code
            print response.text
            raise StrackError("500: Server Error\n %s" % response.text)
        else:
            error_info = "%s: %s" % (response.status_code, response.json()["message"])
            raise StrackError(error_info)

    def _format_result(self, result):
        """
        this method only used in query and crete commands
        Args:
            result:

        Returns:

        """

        new_result = copy.deepcopy(result)
        # refine relation results
        for relation_entity, filed_name in [(field, field) for field in result if field not in self.entity.fields]:
            # get relation entity name
            if "_" in relation_entity:
                relation_entity = "".join(map(lambda i: i[1].title() if i[0] else i[1],
                                              enumerate(relation_entity.split("_"))))  # aaa_bbb_ccc >> aaaBbbCcc
            if relation_entity in [i.split(".")[0] for i in self.entity.relations]:
                # map relation field
                relation_result = new_result.pop(filed_name) or {}
                if isinstance(relation_result, (list, tuple)):
                    str_result = map(self._map_int_to_str, [(relation_entity, i) for i in relation_result])
                    new_result[relation_entity] = map(self._map_fields, [(relation_entity, i) for i in str_result])
                else:
                    new_result[relation_entity] = self._map_fields(
                        [relation_entity, self._map_int_to_str([relation_entity, relation_result])])
        # refile default field result
        new_result = self._map_int_to_str([self.entity.name, new_result])
        # map field name
        new_result = self._map_fields([self.entity.name, new_result])
        # add type
        new_result.update({"type": self.entity.name})
        for key, value in new_result.iteritems():
            if (key == "id" or key.endswith("_id")) and isinstance(new_result.get(key), basestring) and value:
                if value.startswith(","):
                    value = value[1:]
                new_result.update({key: eval(value)})  # eval can convert "2" to 2, "1,2" to (1,2)
        return new_result


class QueryCommand(Command):
    def __init__(self, server_object, cmd, params, entity=None):
        super(QueryCommand, self).__init__(server_object, cmd, params, entity)

        self.__custom = False

        self._params = self.__refactor_params(params)
        # update arguments in doc string
        self.__doc__ = self.help()

    def __refactor_params(self, params):
        for param in params:
            if param.get("attr") == "filters":
                param.update({"attr": "filters",
                              "need": False,
                              "type": "str"})
            elif param.get("attr") == "fields":
                param.update({'attr': 'fields',
                              'need': False,
                              'type': 'list'})
        return params

    def __format_relation_field(self, field):
        if "." in field:
            relation_entity, relation_field = field.split(".")
        else:
            relation_entity, relation_field = field, ""
        # demap field
        relation_field = self.server.demap_field(relation_entity, relation_field)
        return {"entity": relation_entity, "fields": relation_field}

    def __demap_filter_fields(self, filter_dict, all_fields):
        filter_json = json.dumps(filter_dict)
        for field in all_fields:
            new_field = self.server.demap_field(self.entity.name, field)
            filter_json = filter_json.replace('"%s":' % field, '"%s":' % new_field)
        return json.loads(filter_json)

    def __get_filter_keys(self, filter_dict):
        if not isinstance(filter_dict, dict):
            return []
        keys = filter_dict.keys()
        for key, value in filter_dict.iteritems():
            keys.extend(self.__get_filter_keys(value))
        return list(set(keys))

    def __merge_same_fields(self, fields):
        new_fields_dict = {}
        for field_dict in fields:
            key = field_dict.get("entity")
            if key in new_fields_dict:
                new_fields = new_fields_dict.get(key).get("fields")
                field_dict.update({"fields": ",".join([new_fields, field_dict.get("fields")])})
            new_fields_dict.update({key: field_dict})
        return new_fields_dict.values()

    def _walk_map_filter(self, filter_dict):
        for key, value in filter_dict.iteritems():
            if isinstance(value, dict):
                self._walk_map_filter(value)
            elif isinstance(value, list):
                map_lists = VALUE_MAP.get(self.entity.name, {}).get(key, [])
                map_dict = dict([(str(pair[1]), pair[0]) for pair in map_lists])
                filter_dict[key] = [value[0], map_dict.get(value[1], value[1])]

    def _reformat_filters(self, filters_str):
        filter_dict = pfe.parse_filter_expression(filters_str)
        if filter_dict:
            self._walk_map_filter(filter_dict)
        # walk value get all keys
        all_fields = self.__get_filter_keys(filter_dict)
        # map filter fields
        filter_dict = self.__demap_filter_fields(filter_dict, all_fields)
        # validate fields
        for field in all_fields:
            field = self.server.map_field(self.entity.name, field)
            if field not in set(self.entity.fields + self.entity.relations + ["_logic", "0", "1"]):
                raise TypeError("field '%s' in filter is not valid." % field)
        return json.dumps(filter_dict)

    def _reformat_fields(self, fields):
        fields = eval(fields)
        if type(fields) not in [list, tuple]:
            raise TypeError("'fields' must be a list or tuple.")
        main_fields = []
        main_fields_dict = {}
        relation_fields = []
        if "custom" in fields:
            fields.remove("custom")
            main_fields_dict.update({"custom": ""})  # add custom into main field list. do not need any value
            self.__custom = True
        for field in fields:
            if field in self.entity.fields:
                # demap field
                field = self.server.demap_field(self.entity.name, field)
                main_fields.append(field)
            else:
                # field is a relation entity or relation entity.field
                relation_entity = field.split(".")[0]
                if relation_entity in self.entity.relations:
                    field = self.__format_relation_field(field)
                    relation_fields.append(field)
                    # merge same entity fields
                    relation_fields = self.__merge_same_fields(relation_fields)
                else:
                    raise ValueError("'%s' is not a valid field" % field)
        main_fields_str = ",".join(main_fields)
        main_fields_dict.update({"entity": self.entity.name, "fields": main_fields_str})
        fields = {"main": main_fields_dict}
        if relation_fields:
            fields.update({"relation": relation_fields})
        return json.dumps(fields)

    def _reformat_order(self, order):
        # load json
        order_dict = json.loads(order)
        # demap field name
        for attr in order_dict:
            new_attr = self.server.demap_field(self.entity.name, attr)
            order_dict[new_attr] = order_dict.pop(attr)
        # dump json
        order = json.dumps(order_dict)
        return order

    def _init_requests(self, args, kwargs):
        payload, upload_file = self._init_payload(args, kwargs), None
        # convert filter string to dict
        if "filters" in payload:
            payload["filters"] = self._reformat_filters(payload.get("filters"))
        # reformat fields argument
        if "fields" in payload:
            payload["fields"] = self._reformat_fields(payload.get("fields"))
        # reformat empty fields for query commands, because this argument is requisite for api server
        else:
            payload.update({"fields": '{"main": {"entity": "%s", "fields": ""}}' % self.entity.name})
        # reformat order
        if "order" in payload:
            payload["order"] = self._reformat_order(payload.get("order"))
        return payload, upload_file

    def _format_custom(self, result):
        if "custom_value" in result:
            custom_value = result.pop("custom_value")
            for custom_value_dict in custom_value:
                result.update({custom_value_dict.get("variable_code"): custom_value_dict.get("value")})
        return result

    def _success(self, response):
        res = response.json()
        # self.logger.info(res.get("message"))
        result = res.get("data") or {}
        # format value in selected list
        if self.func_name == "select":
            rows = result.get("rows", [])
            if self.__custom:
                rows = map(self._format_custom, rows)
            result = map(self._format_result, rows)
        else:
            if not result:
                return None
            if self.__custom:
                result = self._format_custom(result)
            result = self._format_result(result)
        return result


class CreateCommand(Command):
    """
    requests data of upload query command is different with standard commands
    """

    DEFAULT_STATUS_ID_MAP = {
        "task": {
            "name": "status_id",
            "value": 1
        },
        "asset": {
            "name": "status_id",
            "value": 1
        },
        "shot": {
            "name": "status_id",
            "value": 1
        },
        "sequence": {
            "name": "status_id",
            "value": 1
        },
        "episode": {
            "name": "status_id",
            "value": 1
        },
        "project": {
            "name": "p_status",
            "value": 10
        },
    }

    def __init__(self, server_object, cmd, params, entity=None):
        super(CreateCommand, self).__init__(server_object, cmd, params, entity)

    def help(self):
        doc_str = super(CreateCommand, self).help()
        if not self.entity.creation_field:
            return doc_str
        creation_field_str = ", ".join(self.entity.creation_field)
        return doc_str + "\n\n" + "Required Fields: %s" % creation_field_str

    def _init_data(self, payload):
        fields_dict = json.loads(payload.pop("data"))
        # map str value to int
        fields_dict = self._map_str_to_int([self.entity.name, fields_dict])
        # map fields
        fields_dict = self._demap_fields(fields_dict)
        status_info = self.DEFAULT_STATUS_ID_MAP.get(self.entity.name)
        if status_info and (status_info.get("name") not in fields_dict):
            fields_dict.update({status_info.get("name"): status_info.get("value")})  # set default status
        data_dict = {
            "entity": self.entity.name,
            "fields": fields_dict
        }
        return json.dumps(data_dict)

    def _init_requests(self, args, kwargs):
        payload, upload_file = self._init_payload(args, kwargs), None
        payload["data"] = self._init_data(payload)
        return payload, upload_file

    def _success(self, response):
        res = response.json()
        self.logger.info(res.get("message"))
        result = res.get("data") or {}
        result = self._format_result(result)
        # fixme: this should fixed in backend
        for key, value in result.iteritems():
            if (key == "id" or key.endswith("_id")) and isinstance(result.get(value), basestring):
                if value.startswith(","):
                    value = value[1:]
                result.update({key: eval(value)})  # eval can convert "2" to 2, "1,2" to (1,2)
        return result


class UpdateCommand(Command):
    def __init__(self, server_object, cmd, params, entity=None):
        super(UpdateCommand, self).__init__(server_object, cmd, params, entity)

        self._custom = False
        self._updated_main_fields = []
        self._params = [
            {"attr": "id",
             "need": True,
             "type": "int"},
            {'attr': 'fields',
             'need': True,
             'type': 'dict'}
        ]
        # update arguments in doc string
        self.__doc__ = self.help()

    def _list_to_str(self, fields_dict):
        for key, value in fields_dict.iteritems():
            if isinstance(value, list) or isinstance(value, tuple):
                fields_dict[key] = ",".join(map(str, value))
        return fields_dict

    def _independent_custom(self, fields_dict):
        custom_dict = {}
        fields_dict_copy = copy.deepcopy(fields_dict)
        for field_name in fields_dict:
            if field_name not in self.entity.fields:
                custom_dict.update({field_name: fields_dict_copy.pop(field_name)})
        return fields_dict_copy, custom_dict

    def _init_data(self, payload):
        fields_dict = json.loads(payload.pop("fields"))
        fields_dict = self._list_to_str(fields_dict)
        # pop custom fields
        fields_dict, custom_dict = self._independent_custom(fields_dict)
        # get fields list before map
        self._updated_main_fields = fields_dict.keys()
        # map str value to int
        fields_dict = self._map_str_to_int([self.entity.name, fields_dict])
        # map fields
        fields_dict = self._demap_fields(fields_dict)

        data_dict = {
            "entity": self.entity.name,
            "primary": {
                "key": self.entity.primary_field,
                "value": ["eq", payload.pop("id")]
            },
            "fields": fields_dict
        }
        if custom_dict:
            data_dict.update({"custom": custom_dict})
            self._custom = True
        return json.dumps(data_dict)

    def _init_requests(self, args, kwargs):
        payload, upload_file = self._init_payload(args, kwargs), None
        payload["data"] = self._init_data(payload)
        return payload, upload_file

    def _success(self, response):
        res = response.json()
        data = res.get("data")
        # find this object and return
        fields = self._updated_main_fields
        if self._custom:
            fields.append("custom")
        return self.entity.find("id=%s" % data.get("value"), fields)


class UploadCommand(Command):
    """
    requests data of upload query command is different with standard commands
    """

    PRIMARY_KEY_MAP =  {
        "avatar": "user_id",
        "noteAtt": "note_id",
    }

    def __init__(self, server_object, cmd, params, entity=None):
        super(UploadCommand, self).__init__(server_object, cmd, params, entity)

        self._params = [
            {"attr": "entity_id",
             "type": "int",
             "need": True},
            {"attr": "path",
             "type": "str",
             "need": True},
        ]
        # update arguments in doc string
        self.__doc__ = self.help()

    def _init_requests(self, args, kwargs):
        payload = self._init_payload(args, kwargs)

        primary_key = self.PRIMARY_KEY_MAP.get(self.entity.name, self.entity.primary_field)
        data_dict = {
            "entity": self.entity.name,
            primary_key: payload.pop("entity_id")
        }
        payload["data"] = json.dumps(data_dict)
        # pop path from payload, and put it in upload_file
        file_path = payload.pop("path")
        upload_file = {"file": open(file_path, "rb")}
        return payload, upload_file


class EncodingCommand(Command):
    def __init__(self, server_object, cmd, params, entity=None):
        super(EncodingCommand, self).__init__(server_object, cmd, params, entity)

        self._params = [
            {"attr": "version_id",
             "type": "int",
             "need": True},
            {"attr": "path",
             "type": "str",
             "need": True},
        ]
        # update arguments in doc string
        self.__doc__ = self.help()

    def _init_requests(self, args, kwargs):
        payload = self._init_payload(args, kwargs)
        # generate media_type
        file_path = payload.pop("path")
        if filter(file_path.endswith, [".mp4", ".mov", ".avi"]):
            media_type = 20
        elif filter(file_path.endswith, [".png", ".jpg", ".jpeg"]):
            media_type = 10
        else:
            media_type = 30  # I don't know what is 30
        # put user_id in data
        if media_type == 20:
            data_dict = {
                "entity_type": "version",  # fixme: should be an argument
                "link_id": payload.pop("version_id"),
                "media_type": media_type,
            }
        else:
            # if media not a video file, command should be upload
            self.cmd = "%s/upload" % self.controller
            data_dict = {
                "link_id": payload.pop("version_id"),
                "media_type": media_type,
            }
        payload["data"] = json.dumps(data_dict)
        # put path in upload_file
        upload_file = {"file": open(file_path, "rb")}
        return payload, upload_file


class CustomCommand(Command):
    def __init__(self, server_object, cmd, params, entity=None):
        super(CustomCommand, self).__init__(server_object, cmd, params, entity)

        self._params = [
            {"attr": "project_id",
             "need": True,
             "type": "int"},
        ]
        if self.entity.name == "task":
            self._params.append({"attr": "entity_type",
                                 "need": True,
                                 "type": "str"})
        # update arguments in doc string
        self.__doc__ = self.help()

    def _init_requests(self, args, kwargs):
        payload, upload_file = self._init_payload(args, kwargs), None
        if self.entity.name == "task":
            data_dict = {
                "belong": payload.pop("entity_type"),
                "p_id": payload.pop("project_id")
            }
        else :
            data_dict = {
                "p_id": payload.pop("project_id")
            }
        payload["data"] = json.dumps(data_dict)
        return payload, upload_file
